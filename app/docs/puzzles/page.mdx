import { getBaseMetadata } from '@/lib/utils';

export const metadata = getBaseMetadata({
  title: 'Puzzles',
  description: 'On-chain problems on Curta that players solve to earn Flag NFTs.',
  titleTemplate: '%s | Curta Docs'
});

# Puzzles

Each puzzle inherits `IPuzzle` and implements its 3 functions:

```solidity fileName='IPuzzle.sol' highlightLines={[4, 11, 18]} showLineNumbers={false}
interface IPuzzle {
    /// @notice Returns the puzzle's name.
    /// @return The puzzle's name.
    function name() external pure returns (string memory);

    /// @notice Generates the puzzle's starting position based on a seed.
    /// @dev The seed is intended to be `msg.sender` of some wrapper function or
    /// call.
    /// @param _seed The seed to use to generate the puzzle.
    /// @return The puzzle's starting position.
    function generate(address _seed) external returns (uint256);

    /// @notice Verifies that a solution is valid for the puzzle.
    /// @dev `_start` is intended to be an output from {IPuzzle-generate}.
    /// @param _start The puzzle's starting position.
    /// @param _solution The solution to the puzzle.
    /// @return Whether the solution is valid.
    function verify(uint256 _start, uint256 _solution) external returns (bool);
}
```

The goal of players is to interpret the code, solve the puzzle seeded with their address, then verify the solution on-chain. If the author provided extra information (e.g. Solidity source code), it'll be displayed on the site for players to use. If the solution is valid, a [Flag Token](/docs/flag-token) with the corresponding metadata will be minted to their address.

Since puzzles will be on mainnet, everyone can view everyone else's submissions. The generative aspect prevents front-running and allows for multiple winners: even if players view someone else's solution, they still have to figure out what the rules/constraints of the puzzle are and apply the solution to their respective starting position.
